# 第7章 性能考虑因素

[TOC]

有许多配置参数会影响Pgpool-II的性能。在本章中，我们将介绍如何调整它们。

## 7.1. 资源需求

Pgpool-II不会消耗太多资源。然而，对资源有最低要求。在本节中，我们将逐一解释。

### 7.1.1. 内存需求

Pgpool-II中有两种类型的内存使用：共享内存和进程专用内存。前者在Pgpool-II主服务器进程启动时分配，在整个Pgpool-II服务器关闭之前不会被释放。后者在每个Pgpool-II子进程内分配，并将在进程结束时释放。

#### 7.1.1.1. 共享内存要求

这是一个计算共享内存需求的公式。

```shell
Shared memory requirement (in mega bytes) = 10 + num_init_children * max_pool * 0.02
```

例如，如果你有num_init_children=32（默认值）和max_pool=4（缺省值），那么你需要10+32*4*0.02=12.6 MB。

如果您计划在共享内存中使用内存中的查询缓存（有关更多详细信息，请参阅第5.13节），则需要更多的RAM。有关所需的RAM大小，请参阅memqcache_total_size和memqcache_max_num_cache。

但是，请注意，在Pgpool II 4.1或更高版本中，即使未启用内存中的查询缓存，如果启用了enable_shared_relcache（默认情况下已启用），它也会消耗额外的128MB共享内存。

#### 7.1.1.2. 进程内存要求


这是一个计算进程内存需求的公式。

```shell
Process memory requirement in total (in mega bytes) = num_init_children * 0.16
```

例如，如果num_init_children=32（默认值），则需要5.2MB。请注意，这是Pgpool-II子进程启动时的最低内存要求。一旦进程运行，它将根据消息包大小和其他因素消耗更多内存。建议在开始生产使用之前测量进程实际使用的内存量。

### 7.1.2. 磁盘要求

Pgpool-II不消耗太多磁盘空间。此外，它不需要高速磁盘，因为Pgpool-II引起的磁盘I/O流量很小。但是，如果您计划发出大量日志，当然需要为它们提供磁盘空间。

## 7.2. 管理客户端连接

随着接受的客户端连接数量的增长，可以接受来自客户端的新连接的Pgpool-II子进程的数量正在减少，最终达到0。在这种情况下，新客户端需要等到子进程空闲。在重负载下，等待客户端的队列长度可能会越来越长，最终达到系统的限制（您可能会看到“535倍套接字的侦听队列溢出”错误）。在这种情况下，您需要增加队列限制。有几种方法可以处理此问题。

### 7.2.1. 控制num_init_children

处理这个问题的明显方法是增加子进程的数量。这可以通过调整num_init_children来实现。然而，增加子进程需要更多的CPU和内存资源。此外，你必须非常小心PostgreSQL的max_connections参数，因为一旦子进程的数量大于max_connects，PostgreSQL就会拒绝接受新的连接，并触发故障转移。

增加num_init_children的另一个缺点是所谓的“雷鸣般的群体问题”。当新的连接请求进来时，内核会唤醒任何正在休眠的子进程，发出accept（）系统调用。这会触发进程争夺套接字的斗争，并可能给系统带来沉重的负载。为了缓解这个问题，您可以将serialize_accept设置为on，这样就只有一个进程可以获取接受套接字。但是，请注意，当并发客户端数量较少时，性能可能会下降。

在Pgpool II 4.4或更高版本中，可以使用process_management_mode进行更有效的管理。通过将进程管理模式设置为动态，当并发客户端数量较少时，可以减少Pgpool-II的子进程数量，从而节省资源消耗。另一方面，当并发客户端的数量增加时，子进程的数量也会增加，以便它能够响应更多的连接需求。但是，请注意，建立连接的时间可能会增加，因为需要启动新进程才能拥有更多的子进程。

关于过程管理模式的理解，请参见第3.3.3节。

### 7.2.2. 控制listen_backlog_multipler

另一种解决方案是增加连接请求队列。这可以通过增加listen_backlog_multipler来实现。

### 7.2.3. 何时使用reserved_connections

然而，上述解决方案都不能保证接受队列的连接不会被填满。如果客户端连接请求的到达速度快于处理查询的速度，那么队列总有一天会被填满。例如，如果有一些需要很长时间的繁重查询，则很容易引发问题。

解决方案是设置reserved_connections，以便像PostgreSQL一样拒绝溢出的连接请求。这会给应用程序带来可见的错误（“抱歉，max_connections已经存在”），并迫使它们重试。因此，只有当您无法预见系统负载的上限时，才应使用该解决方案。

## 7.3. 读取查询负载平衡

如果有多个PostgreSQL节点，并且Pgpool-II在流式复制模式、逻辑复制模式、慢模式或复制模式下运行（有关运行模式的更多详细信息，请参阅第3.3.2节），则可以在这些数据库节点之间分配读取查询以获得更高的吞吐量，因为每个数据库节点处理的查询数量较少。要启用该功能，您需要打开load_balance_mode。

目前，绝大多数系统都使用流式复制模式，因此从现在开始，我们将重点关注该模式。

### 7.3.1. 会话级负载平衡与语句级负载平衡

默认情况下，负载平衡模式为“会话级别”，这意味着发送的节点读取查询是在客户端连接到Pgpool-II时确定的。例如，如果我们有节点0和节点1，则每次创建新会话时，都会随机选择其中一个节点。从长远来看，选择哪个节点的可能性将越来越接近backend_weight0和backend_wight1指定的比率。如果这两个值相等，则每个节点被选中的机会将是偶数。

另一方面，如果statement_level_load_balance设置为On，则负载平衡节点将在每次查询开始时确定。这在应用程序有自己的连接池的情况下很有用，该连接池会继续连接到Pgpool-II，并且一旦应用程序启动，负载平衡节点就不会更改。另一个用例是批处理应用程序。它会发出大量的查询，但只有一个会话。通过语句级负载平衡，它可以利用多个服务器。

### 7.3.2. 创建专用数据库节点

在OLAP环境中，有时需要有一个用于特定目的的大型只读数据库。通过使用流式复制创建副本数据库，可以创建这样的数据库。在这种情况下，可以通过两种方式将读取查询重定向到数据库：指定数据库名称或指定应用程序名称。对于前者，使用database_redirect_preference_list。对于后者，请使用app_name_redirect_preference_list。

## 7.4. 内存查询缓存

Pgpool-II允许缓存读取查询结果以供以后使用。这将为多次发出相同读取查询的应用程序带来巨大的好处。如果有两个查询，并且查询字符串（准备好的语句的参数，如果有的话）相同，则两个查询被视为“相同”。在第一次发送查询时，Pgpool-II会保存查询结果，并将其用于第二次查询，而无需向PostgreSQL询问任何事情。第5.13节对该技术进行了说明。

### 7.4.1. 何时不使用内存中的查询缓存

修改表时，可以更改表的查询结果。为了避免不一致，当修改相应的表时，Pgpool-II会丢弃查询缓存数据。因此，频繁更新的数据库将不适合使用内存中的查询缓存。您可以检查您的数据库是否适合使用查询缓存，您可以使用SHOW POOL_CACHE。如果查询缓存命中率低于70%，您可能希望避免使用查询缓存。

## 7.5. 关系缓存

除了原始模式（见第3.3.2节）或load_balance_mode设置为关闭外，有时Pgpool-II需要要求PostgreSQL获取元信息，例如表是否是临时表。为了获取这些信息，Pgpool-II向主PostgreSQL发送查询，最多可达10个查询（在4.1或之后，查询数量有所减少，但不是零）。为了减少开销，Pgpool-II维护了“关系缓存”。下次查询中包含相同的表时，Pgpool-II会从缓存中提取信息。

有一些参数可以配置关系缓存。有关更多详细信息，请参阅relcache_expire、relcache_size、check_temp_table、check_unlogged_table。

### 7.5.1. 共享关系缓存

关系缓存基本上存在于绑定到进程的进程专用内存中。因此，即使为表创建了关系缓存，在不同的进程中也可能尚未创建关系缓存。毕竟，在所有进程中创建关系缓存条目之前，查询会继续发送到PostgreSQL。Pgpool-II 4.1通过在共享内存中创建关系缓存克服了这个问题。如果一个会话在共享内存中创建了一个关系缓存条目，其他会话将通过查看共享关系缓存来获得缓存结果。有关更多详细信息，请参阅enable_shared_relcache配置参数部分。此功能非常有效，我们建议启用此功能。

## 7.6. 其他性能考虑因素

本节介绍一些其他性能考虑因素。

### 7.6.1. 雷鸣般的羊群问题

如果num_init_children很大，则可能会唤醒许多Pgpool-II进程，并发生大量上下文切换。这会导致高系统负载并损害整体系统性能。这个问题被称为“雷鸣般的羊群问题”。启用serialize_accept可以解决此问题。请注意，对于较小的num_init_children，serialize_occept可能会使系统性能变差。请查看serialize_occept部分中的指导。

### 7.6.2. 灾难恢复设置

要创建灾难恢复设置，可以在地理位置较远的地方部署一个Pgpool-II加PostgreSQL主服务器和另一个Pgpool-II加PostgreSQL备用服务器。靠近备用服务器的客户端向Pgpool-II发送只读查询，因为Pgpool-II靠近备用服务器。然而，由于备用Pgpool-II向主PostgreSQL服务器的系统目录发送内部查询，查询性能可能会越来越差。为了避免这个问题，可以使用relcache_query_target，以便将此类查询发送到备用服务器。有关更多详细信息，请参阅relcache_query_target。